# 운영체제: 메모리 관리
> ✅ 가상 메모리의 기초 <br>

> [01. 가상 메모리의 개요](https://github.com/YangYubin12/OperatingSystem/blob/master/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98%EA%B8%B0%EC%B4%88.md#-01-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EA%B0%9C%EC%9A%94) <br>
> [02. 페이징 기법](https://github.com/YangYubin12/OperatingSystem/blob/master/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98%EA%B8%B0%EC%B4%88.md#-02-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95) <br>
> [03. 세그먼테이션 기법](https://github.com/YangYubin12/OperatingSystem/blob/master/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98%EA%B8%B0%EC%B4%88.md#-03-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95) <br>
> [04. 세그먼테이션-페이징 혼용 기법](https://github.com/YangYubin12/OperatingSystem/blob/master/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98%EA%B8%B0%EC%B4%88.md#-4-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8E%98%EC%9D%B4%EC%A7%95-%ED%98%BC%EC%9A%A9-%EA%B8%B0%EB%B2%95) <br>
> [05. 캐시 매핑 기법](https://github.com/YangYubin12/OperatingSystem/blob/master/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98%EA%B8%B0%EC%B4%88.md#-5-%EC%BA%90%EC%8B%9C-%EB%A7%A4%ED%95%91-%EA%B8%B0%EB%B2%95) <br>

## <br> 01. 가상 메모리의 개요
### 1.1 가상 메모리?
> 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술 <br>
> 가상 메모리를 이용하면 프로세스는 운영체제가 어디 있는지, 물리 메모리의 크기가 어느 정도인지 신경쓰지 않고 메모리를 마음대로 사용 가능
<br>

### 1.2 가상 메모리의 구성
* 크게 프로세스가 바라보는 메모리 영역과, 메모리 관리자가 바라보는 메모리 영역으로 나뉨
* 가상 메모리에서 메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충
  
  ![image](https://github.com/YangYubin12/OperatingSystem/assets/102217712/1b4624fa-6097-4b96-b77b-a8548fe9155a)
<br>

### 1.3 가상 메모리의 크기와 동적 주소 변환
* 가상 메모리의 크기
  - 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리(실제 메모리)와 스왑 영역을 합한 크기
* 동적 주소 변환
  * 가상 주소를 실제 메모리의 물리 주소로 변환
  * 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자의 데이터를 물리 메모리에 배치 가능
<br>

### 1.4 가상 메모리의 메모리 분할 방식
* 가변 분할 방식을 이용한 세그먼테이션과 고정 분할 방식을 이용한 페이징 기법이 있음
* 기본적으로 페이징 기법을 사용하나 페이지 테이블 관리가 어려움
* 세그먼테이션 기법은 외부 단편화 등의 문제가 있음
* 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용
  
  <img width="706" alt="스크린샷 2023-11-01 오전 8 43 19" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/560de112-6f9c-4cc5-82b2-37e94506dbd2">
<br>

### 1.5 메모리 매핑 테이블
가상 메모리 시스템에서 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리
  <img width="820" alt="스크린샷 2023-11-01 오전 8 44 48" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/4cb37791-bcfe-4606-9bff-7b285e7fdd96">
  
## <br> 02. 페이징 기법
### 2.1 페이징 기법의 구현
* 페이징 기법?
  * 고정 분할 방식을 이용한 가상 메모리 관리 기법
  * 물리 주소 공간을 같은 크기로 나누어 사용
  * 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0번지부터 시작
<br>

* 페이지와 프레임
  * 가상주소의분할된각영역을페이지라고하며번호를매겨관리
  * 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임이라고 함(프레임도 페 이지처럼 번호를 매겨 관리)
  * 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있음
  * 어떤 페이지가 어떤 프레임에 있는지에 대한 연결(매핑) 정보는 페이지 테이블에 담겨 있음
  * 페이지 테이블에 invalid는 해당 페이지가 스왑 영역에 있다는 의미

    <img width="567" alt="스크린샷 2023-11-01 오전 8 54 15" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/6f11f2dc-dc9f-44f9-b12b-8c0e35d58011">
<br>

### 2.2 페이징 기법의 주소 변환
<b>프로세스가 30번지의 내용을 읽으려고 할 때 주소 변환 과정: </b>
  1. 가상 주소 30번지가 어느 페이지에 있는지 찾음(30번지는 페이지 3의 0번째 위치에 있음: VA=<3, 0>)
  2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아냄
  3. 최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근(이 주소가 가상 주소 30번지 의 물리 주소)
    <img width="765" alt="스크린샷 2023-11-01 오전 8 57 02" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/526c2617-ca30-4f04-9733-f471efdfb0bc">
<br>

<b>프로세스가 가상주소 18번지에 값을 저장하려고 할 때 주소 변환 과정: </b>
  1. 가상 주소 18번지가 어느 페이지에 있는지 찾음(18번지는 페이지 1의 8번째 위치에 있음: VA=<1 ,8>)
  2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아냄
  3. 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장
    <img width="929" alt="스크린샷 2023-11-01 오전 8 57 54" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/fe61ddc4-f771-43f1-b954-f27bb4c2c805">
<br>

<b>정형화된 주소 변환:</b>
  * 페이징 기법에서는 가상 주소를 VA=<P, D>로 표현
    * VA : 가상 주소 virtual address
    * P : 페이지 page
    * D : 페이지의 처음 위치에서 해당 주소까지의 거리 distance

  * 페이징 기법에서의 주소 변환은 가상 주소 VA=<P, D>를 물리 주소 PA=<F, D>로 변환하는 것
    * PA: 물리메모리의 주소를 가리키는 용어로 물리 주소 또는 실제 주소
    * F : 프레임 frame
    * D : 프레임의 처음 위치에서 해당 주소까지의 거리 distance
<br>

<b>페이징 기법의 주소 변환 과정: </b>
  * VA=<P, D> → PA=<F, D>
  * 페이지 테이블을 사용하여 P는 F로 바꾸고 D는 변경 없이 그대로 씀
  * D를 변경하지 않는 이유는 페이지와 프레임의 크기를 똑같이 나누었기 때문
    <img width="794" alt="스크린샷 2023-11-01 오전 9 07 27" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/c6b49b9b-f6c1-472b-bcb9-18d8130432e0">
<br>

<b>페이지의 크기가 다양할 경우 가상 주소를 <P, D>로 변환하는 공식: </b>
> P = 나눗셈 (가상 주소 / 한 페이지의 크기)의 몫<br>
> D = 나눗셈 (가상 주소 / 한 페이지의 크기)의 나머지
  * 한 페이지의 크기가 10B인 가상 메모리 시스템에서 가상 주소 32번지
    * P=3(32/10의 몫)
    * D=2(32/10의 나머지)
  * 한 페이지의 크기가 512B인 시스템에서 가상 주소 2049번지
    * P=4(2049/512의 몫)
    * D=1(2049/512의 나머지)
<br>

<b>16bit CPU의 컴퓨터에서 한 페이지의 크기가 210B일 때 페이징 시스템: </b>
  * 한 프로세스가 사용할 수 있는 가상 메모리의 크기는 2의 16승(65,536)B
  * 사용자는 0번지부터 65535(216-1)번지까지 가상 주소 공간을 사용 가능
  * 가상 주소로 사용할 수 있는 16bit 중 6bit는 페이지 번호로, 10bit는 페이지의 처음 위 치에서 해당 주소까지의 거리
    <img width="771" alt="스크린샷 2023-11-01 오전 9 15 36" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/ac76f8c8-74de-473c-ba4a-2298cf63b6b3">
 
  * 전체 페이지의 수는 26, 즉 64개이고 페이지 0번부터 63번까지 존재
  * 물리 주소도 가상 주소와 같이 1,024B로 나뉨. 프레임은 0부터 31까지만 있다고 가정
  * 페이지 테이블은 페이지 테이블 엔트리가 0~63으로 총 64개(페이지 테이블의 크기는 물리 주소의 크기가 아니라 프로세스의 크기에 비례)
    <img width="696" alt="스크린샷 2023-11-01 오전 9 20 28" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/d064d381-7d54-4828-87b5-21ebc13ce8b2">
<br>

<b>프로세스가 980번지에 저장된 데이터를 요청했을 때 동적 주소 변환: </b>
  * 가상 주소 980번지의 페이지 P, 거리 D를 구함
    * P=0(980/1024의 몫), D=980(980/1024의 나머지) → VA=<0, 980>
  * 페이지 테이블로 가서 페이지 0이 프레임 2에 저장되어 있다는 것을 확인
  * 물리 메모리의 프레임 2 시작 지점으로부터 980번지 떨어진 곳에 접근하여 데이터를 가져옴
    <img width="681" alt="스크린샷 2023-11-01 오전 9 21 19" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/42301f56-81ec-480f-989e-7baaca120e7b">
<br>

### 2.3 페이지 테이블 관리
<b>다수의 프로세스가 있는 페이징 시스템: </b>
  * 프로세스마다 페이지 테이블이 존재
  * 프로세스의 수가 많아지면 페이지 테이블의 크기가 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어듬
  * 페이지 테이블 크기를 적정하게 유지하는 것은 페이지 테이블 관리의 핵심
    <img width="677" alt="스크린샷 2023-11-01 오전 9 25 40" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/0b0840af-ab3e-48e2-b971-a6d6770ddef9">
<br>

<b>물리 메모리 내 페이지 테이블의 구조: </b>
  * 각 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터Page Table Base Register, PTBR에 보관
  *  물리 메모리의 크기가 작을 때는 프로세스만 스왑 영역으로 옮겨지는 것이 아니라 페 이지 테이블의 일부도 스왑 영역으로 옮겨짐
    <img width="722" alt="스크린샷 2023-11-01 오전 9 28 22" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/ffba5abf-15c0-468d-9a50-7347274983bb">
<br>

### 2.4 페이지 테이블 매핑 방식
<img width="700" alt="스크린샷 2023-11-01 오전 9 29 24" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/7e6835e1-d3b6-460e-8176-4608594c9ff6">

* 직접 매핑 direct mapping
  * 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식
  * 별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라고 부름
    
<br>

* 연관 매핑 associative mapping
  * 페이지 테이블 전체를 스왑 영역에서 관리하는 방식
  * 물리메모리의여유공간이작을때사용하는방식
  * 모든 페이지 테이블을 저장장치의 스왑 영역에 저장하고 그중 일부만 물리 메모리에 가져옴
  * 일부 내용만 무작위로 가져오기 때문에 페이지 번호와 프레임 번호 둘 다 표시
  * 주소 변환 시 물리 메모리 내의 페이지 테이블을 다 검색해야 하며 만약 원하는 프레임 번호를 얻지 못하면 스왑 영역에 있는 페이지 테이블 검색
  * 검색 실패 시 스왑 영역에서 다시 찾아야 하므로 시간을 낭비하게 됨

<br>

* 집합-연관 매핑set-associative mapping
  * 연관 매핑에서는 물리 메모리에 있는 데이터가 무작위로 올라오기 때문에 원하는 프레임 번호를 얻기 위해 모든 테이블을 검색해야 하는 문제 존재
  *  집합-연관 매핑은 디렉토리 매핑이라고도 부름
  *  집합-연관 매핑에서는 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져옴
  *  페이지 테이블을 n개씩 자르고 이를 관리하는 페이지 테이블을 하나 더 생성
  *  새로 생성한 집합 테이블에는 일정하게 자른 페이지 테이블이 물리 메모리에 있는지, 스왑 영역에 있는지에 대한 위치 정보를 표시
  *  연관 매핑과 비교했을 때 집합 테이블을 통해 원하는 페이지 테이블 엔트리가 스왑 영역에 있는지, 물리 메모리에 있는지 간단히 파악할 수 있음
  *  연관매핑과 집합 집합-연관 매핑은 캐쉬에서 사용하는 방식

<br>

* 역매핑invert mapping
  * 물리 메모리의 프레임 번호를 기준으로 테이블을 구성
  * 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지 표시
  * 프로세스 수와 상관없이 테이블이 하나만 존재하므로 테이블의 크기가 매우 작음
  * 프로세스가 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점이 있음

<br>

<b>직접 매핑 방식의 구조:</b>
  * 페이지 테이블 전체가 물리 메모리에 저장되기 때문에 가상 주소 VA=<P, D>를 물리 주소 PA=<F, D>로 변환하려면 페이지 테이블의 P번째 위치(PTE P)에서 원하는 프레임 값을 얻을 수 있음
  * 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있으므로 물리 메모리상 페이지 테이블의 P번째 주소가 시작 주소로부터 P번째 위치에 존재

    <img width="687" alt="스크린샷 2023-11-01 오전 9 39 24" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/13b0db9e-7363-4dea-91dc-f178fb1ab1b2">
<br>

<b>연관 매핑 방식의 구조: </b>
  * 메모리에 접근하기 위해 먼저 변환 색인 버퍼(Translation Look-ahead Buffer, TLB)를 찾음
    * TLB히트:원하는페이지번호가변환색인버퍼에있는경우로,곧바로물리주소로변환
    * TLB미스:원하는페이지번호가변환색인버퍼에없는경우로,스왑영역에저장된직접 매핑 테이블을 사용하여 프레임 번호로 변환
  * 전체 페이지 테이블을 물리메모리에 보관하지 않아 메모리를 절약 할 수 있음
  * TLB 미스가 빈번하게 발생할 경우 시스템의 성능이 떨어지는 단점 존재
  * 변환 색인 버퍼는 페이지 테이블의 일부를 무작위로 가지고 있기 때문에 모든 변환 색인 버퍼를 검색한 후에야 원하는 페이지가 메모리에 없다는 것을 알 수 있음

    <img width="778" alt="스크린샷 2023-11-01 오전 9 52 12" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/ca1364fa-7c69-4042-a137-b659948091b0">
<br>

<b>집합-연관 매핑: </b>
  * 방식:
    * 페이지 테이블을 같은 크기의 여러 묶음으로 나누고, 각 묶음의 시작 주소를 가진 디렉터리 테이블을 새로 만들어 관리
    * 전체 페이지 테이블은 스왑 영역에 있으며, 일부 테이블은 묶음 단위로 메모리로 옮김
    * 해당 묶음이 현재 메모리에 있는지, 스왑 영역에 있는지를 표시하는 디렉터리 테이블을 새로 만듦
    * 디렉터리 테이블을 살펴보면 원하는 테이블 묶음이 어디에 있는지 알 수 있으므로 전체 테이블을 찾아보지 않아도 TLB 미스를 바로 알 수 있음
  * 가상 주소:
    * 페이지 테이블이 일정 크기의 묶음으로 나뉘기 때문에 가상 주소를 VA=<P, D>가 아니라 VA=<P1, P2, D>로 바꾸어 표시
      * P1: 디렉터리 테이블에서의 위치 정보
      * P2: 묶음 내에서의 위치 정보
    * 페이지 테이블을 10개씩 한 묶음으로 나눌 경우 0~9번 테이블은 0번 디렉터리에, 10~19번 테 이블은 1번 디렉터리에 속함
      * 가상 주소 32번지: <0,3,2>로 변환
      * 가상 주소 127번지: <1,2,7>로 변환
  * 구조:
    * 디렉터리 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있음
    * 프로세스가 특정 주소를 요구하면 VA=<P1, P2, D>로 변환되고, P1을 이용하여 디렉터리 테이 블에서 주소를 찾음
    * 만약 I(invalid)라고 표시되어 있으면 TLB 미스가 발생한 것
    * 원하는 테이블이 물리 메모리에 있으면 묶음 테이블의 시작 주소가 명시되어 있음

      <img width="784" alt="스크린샷 2023-11-01 오전 9 56 22" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/d7c77fd9-a8d8-4791-97c9-3470d92d39db">

<br>

<b>역매핑: </b>
  * 방식:
    * 물리 메모리의 프레임 번호를 기준으로 테이블 작성     
      <img width="685" alt="스크린샷 2023-11-01 오전 9 57 41" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/b7ae0f4d-2650-4444-b52a-3a0659426b41">
  
  * 구조:
    * 테이블이 <프레임 번호, 프로세스 아이디, 페이지 번호>로 구성
    * 페이지 테이블의 행수는 실제 프레임의 수와 같음
    * 프로세스의 수와 상관없이 항상 일정 크기의 페이지 테이블을 유지하여 테이블의 크기가 매우 작음
    * 주소 변환 시 메모리 관리자는 주소 변환을 해야 하는 프로세스의 아이디와 페이지 번호가 물리 메모리에 있는지 역매핑 테이블에서 검색
    * 현재 테이블에 원하는 데이터가 없으면 스왑 영역에서 가져옴
    * 페이지 테이블을 다 검사한 후에야 저장장치에 접근하기 때문에 검색 시간을 낭비하는 단점이 있음

      <img width="460" alt="스크린샷 2023-11-01 오전 9 58 43" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/584df029-63ad-40bf-8ab7-0234b70cc4e0">

## <br> 03. 세그먼테이션 기법
### 3.1 세그먼테이션 기법의 구현
<b>세그먼테이션 테이블 segmentation table?</b>
  * 세그먼트의 크기를 나타내는 limit와 물리 메모리상의 시작 주소를 나타내는 address가 있음
  * 각 세그먼트가 자신에게 주어진 메모리 영역을 넘어가면 안 되기 때문에 세그먼트 의 크기 정보에는 크기를 뜻하는 size 대신 제한을 뜻하는 limit를 사용
  * 세그먼테이션 기법에서도 물리 메모리가 부족할 때 스왑 영역을 사용
  * 크기가 100B인 프로세스 D(세그먼트 3)가 스왑 영역에 있고, 세그먼테이션 테이블 의 address에 I(invalid)라고 표시되어 있음

    <img width="734" alt="스크린샷 2023-11-01 오전 10 11 08" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/fe887008-1243-40f9-95c1-9143c7bc9df7">

<br>

### 3.2 세그먼테이션 기법의 주소 변환
<b>프로세스 A의 32번지에 접근할 때 주소 변환 과정: </b>
  1. 가상 주소를 구함(VA =<0, 32>)
  2. 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후 시작 주소 120에 거리 32를 더하여 물리 주소 152번지를 구함<br>(이때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검하고 만약 크다면 메모리 오류를 출력하고 해당 프로세스를 강제 종료하며, 크지 않다면 물리 주소를 구함)
  3. 물리 주소 152번지에 접근하여 원하는 데이터를 읽거나 씀

     <img width="632" alt="스크린샷 2023-11-01 오전 10 17 59" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/69dc04fa-5c9c-4341-85e7-c65595ad1396">

## <br> 4. 세그먼테이션-페이징 혼용 기법
### 4.1 접근 권한
* 메모리 접근 권한
  * 메모리의 특정 번지에 저장된 데이터를 사용할 수 있는 권한
  * 읽기(read), 쓰기(write), 실행(execute), 추가(append) 권한이 있음

    <img width="620" alt="스크린샷 2023-11-01 오전 10 42 23" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/3e65f412-c66d-4ed7-9f96-7ae8cfe412b6">

<br>

* 프로세스의 영역별 메모리 접근 권한
  * 코드 영역 : 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행 권한을 가짐
  * 데이터 영역 : 데이터는 크게 읽거나 쓸 수 있는 데이터와 읽기만 가능한 데이터로 나 눌 수 있음 (일반적인 변수는 읽거나 쓸 수 있으므로 읽기 및 쓰기 권한을 가지고 상수 로 선언한 변수는 읽기 권한만 가짐)

    <img width="607" alt="스크린샷 2023-11-01 오전 10 42 55" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/addfc843-dedd-497a-b3ed-24d66740e6ce">

<br>

### 4.2 세그먼테이션-페이징 혼용 기법의 도입
* 페이징 기법에서 메모리 접근 권한까지 고려한 페이지 테이블 예
  * 페이지마다 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한과 관련된 권한 비트(right bit) 추가
  * 메모리 관리자는 주소 변환이 이루어질 때마다 페이지 테이블의 권한 비트를 이용하 여 유용한 접근인지 아닌지 확인
  * 페이지 테이블에 권한 비트가 추가되면 페이지 테이블의 크기가 커지는 문제가 있음 (이 문제를 완화하려면 반복되는 권한 비트를 줄여야 함)
    
    <img width="728" alt="스크린샷 2023-11-01 오전 10 45 27" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/f9c70732-fec7-4b80-ad04-e5d424bb7446">

<br>

* 세그먼테이션-페이징 혼용 기법
  
  <img width="828" alt="스크린샷 2023-11-01 오전 10 46 20" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/7c48bc0d-6946-4ec8-8f22-416920731d9b">

<br>

### 4.3 세그먼테이션-페이징 혼용 기법의 주소 변환
* 세그먼테이션-페이징 혼용 기법에서 동적 주소 변환 과정
  1. 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져 있는지 계산하여 가상 주소 VA =<S, P, D>를 구함
  2. 세그먼테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는 불법 접근이 아닌 지, 권한이 없는 페이지에 접근하는 것은 아닌지 등을 확인(만약 권한이 없는 페이지에 접근하거나 자신에게 주어진 메모리 영역을 벗어나면 세그먼테이션 오류(트랩)를 발생시켜 프로세스 를 강제 종료하고, 그렇지 않으면 연결된 페이지 테이블로 감)
  3. 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 찾음(만약 물리 메모리에 프레임이 있다면 메모리에 바로 접근하고, 없다면 스왑 영역에 가서 해당 페이지를 물리 메모리로 가져옴)
  4. 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 씀
     
     <img width="740" alt="스크린샷 2023-11-01 오전 10 47 53" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/ba722877-8679-4498-aad3-e2095bbfa709">

## <br> 5. 캐시 매핑 기법
### 5.1 캐시 직접 매핑
* 메모리의 블록이 캐시로 올라올 때 항상 같은 위치에 올라옴
* 캐시는 메모리의 어떤 블록에서 올라온 페이지인지만 확인
* CPU가 메모리에 접근하려는 주소 <P, D>는 <tag, bd, D>로 바꿀 수 있고, 원하는 데이터를 캐시에 얻기 위해 <tag, D>를 사용
* 태그: 캐시에블록번호를명시하는것
* bdblock distance: 블록에서의 거리를 의미

<br>

* 캐시 직접 매핑의 예
  * 현재 캐시의 00 위치에 lion, chicken, tuna, snake 중 어떤 데이터가 올라왔는지 확인하기 위해 캐시에서는 태그를 유지
  * 태그는 메모리 주소의 앞 2bit에 해당하는 값으로, 어떤 블록에서 올라온 데이터인 지를 나타냄
  * CPU가 메모리 워드 1101의 cobra를 필요로 하는 경우 CPU는 캐시의 01 위치(주소 의 뒷자리)에 가서 태그가 11인지 확인하는데 태그가 11이므로 캐시 히트
  * 0111의 crow가 필요하다면 먼저 캐시의 11 위치로 가서 태그가 01인지 확인하는 데 캐시의 11 위치 태그가 현재 00이므로 캐시 미스가 발생하고, CPU는 메모리의 0111로 가서 crow를 가져옴

    <img width="723" alt="스크린샷 2023-11-01 오전 10 49 08" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/aa786170-30b1-42b9-87fb-e560a56f5b50">

<br>

### 5.2 캐시 연관 매핑
* 메모리 워드가 캐시의 어느 위치에도 자유롭게 올라갈 수 있으므로 캐시가 메모리 워드의 주소를 전부 가지고 있음
* CPU가 특정 주소를 필요로 할 때 캐시에서 검색하여 찾는 경우는 캐시 히트이지만, 찾지 못하면 캐시 미스가 발생하여 메모리에서 원하는 데이터를 가져옴
* 장점 : 캐시 메모리를 자유롭게 사용할 수 있음
* 단점 : 캐시 히트인지, 캐시 미스인지 확인하기 위해 캐시의 모든 주소를 검색해야 함

  <img width="669" alt="스크린샷 2023-11-01 오전 10 50 54" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/781e5f99-e068-461e-9ba4-248876e08265">

<br>

### 5.3 캐시 집합-연관 매핑
* 캐시를 K개의 집합으로 나누고 각 집합에 직접 매핑을 사용
* 직접 매핑을 하는 캐시 메모리를 K개로 나눔으로써 같은 끝자리를 가진 캐시 메모 리도 K개가 되기 때문에 직접 매핑의 자리 다툼 문제가 완화됨
* 집합 내에서 직접 매핑을 사용하기 때문에 바로 캐시 히트 여부를 알 수 있음

* 캐시 집합-연관 매핑의 예
  * 캐시를 2개의 집합(K=2)으로 나누고 하나의 집합에 2개의 페이지를 사용
  * 주소 P의 4bit 중 마지막 1bit만 bd를 나타내고 태그는 앞의 3bit
  * 주소의 끝이 0인 페이지는 2개의 집합 중 비어 있는 첫 번째 위치에 들어가고, 끝이 1인 페이지는 2개의 집합 중 비어 있는 마지막 위치에 들어감

    <img width="647" alt="스크린샷 2023-11-01 오전 10 52 02" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/45456a7b-9394-4da1-9fc0-4348a099cafe">

<br>

## 출처
* [출처 1: [컴퓨터구조]가상 메모리(Virtual memory)](https://jesus-never-fail.tistory.com/30)
* [출처 2: 페이징 기법](https://mgyo.tistory.com/462)
* Chapter 08 가상 메모리의 기초 PPT
