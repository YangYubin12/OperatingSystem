# 운영체제: 메모리 관리
> ✅ 물리 메모리 관리

## <br> 1. 메모리 관리의 개요
## 1.1 메모리 관리의 복잡성 및 이중성
### 메모리 주소
- 1B로 나뉜 메모리의 각 영역은 메모리 주소로 구분, 보통 0번지부터 시작
- CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용


### <br> 메모리 관리의 복잡성
- 메모리는 폰노이만 구조의 컴퓨터에서 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행 가능
- 일괄처리 시스템은 한번에 하나의 프로그램만 실행시킴으로 메모리 관리가 <b>단순</b>
- 시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 <b>복잡</b>

### <br> 메모리 관리의 이중성
- 프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어함

## <br> 1.2 소스코드의 번역과 실행
### 컴파일러의 목적
- 오류 발견 : 소스코드에서 오류를 발견하여 실행 시 문제가 없도록 함
- 코드 최적화 : 소스코드를 간결하게 정리하여 실행 속도를 빠르게 함

### <br> 컴파일러 인터프리터 차이

<img width="714" alt="스크린샷 2023-09-01 오전 9 39 47" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/dee06b62-dbda-4c95-a485-84d37601577f">

### <br> 컴파일 과정
1. 소스코드 작성 및 컴파일: 에러찾기와 최적화
2. 목적 코드와 라이브러리 연결
3. 동적 라이브러리를 포함하여 최종 실행: 라이브러리 내의 함수가 변경되면 다시 컴파일 해야 했지만, 동적 라이브러리는 실행 시에 포함됨으로 재 컴파일 필요 없음 

## <br> 1.3 메모리 관리자의 역할
### 메모리 관리자
> 메모리 관리를 담당하는 하드웨어, 하드웨어 측면에서는 메모리 관리 유닛(Memory Management Unit, MMU)이 메모리 관리를 지원

### <br> 메모리 관리자의 작업
- 가져오기 작업 : 프로세스와 데이터를 메모리로 가져옴
- 배치 작업 : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정
- 재배치 작업 : 꽉 차 있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보냄

### <br> 메모리 관리자의 정책
- 가져오기 정책 : 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책
- 배치 정책 : 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책
- 재배치 정책 : 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책 

## <br> 2. 메모리 주소
## 2.1 32bit CPU와 64bit CPU의 차이
### CPU의 비트
- 한 번에 다룰 수 있는 데이터의 최대 크기, 워드(word)라 부름
- 32bit CPU는 한 번에 다룰 수 있는 데이터의 최대 크기가 32bit(1word = 32bit)
- 32bit CPU 내의 레지스터 크기는 전부 32bit, 산술 논리 연산장치와 대역폭도 32bit

### <br> 32bit CPU의 메모리 크기 
- 표현할 수 있는 메모리 주소의 범위 0~2의 32승-1, 총개수 2의 32승
- 16진수로 나타내면 00000000~FFFFFFFF, 총크기는 2의 32승B(약 4GB)

### <br> 64bit CPU의 메모리 크기 
- 0~2의 64승-1번지의 주소 공간을 제공
- 총 크기가 2의 64승B, 약 16,777,216TB로 거의 무한대에 가까운 메모리 사용 가능

<img width="855" alt="스크린샷 2023-09-11 오후 3 45 25" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/9359d83e-65d3-4c65-99e4-575870691f14">

### <br> 물리 주소 공간과 논리 주소 공간 
- 물리 주소 공간 : 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 크기가 다름 
- 논리 주소 공간 : 사용자 입장에서 바라본 주소 공간 

## <br> 2.2 절대 주소와 상대 주소 
### 단순 메모리 구조 
- 한 번에 한 가지 일만 처리하는 일괄 처리 시스템에서 볼 수 있음
- 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리
  
<img width="316" alt="스크린샷 2023-09-11 오후 3 38 05" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/e5c257f5-98d7-4cd3-a87f-818f027c05c8">

### <br> 단순 메모리 구조에서 사용자 프로세스 적재
- 사용자 프로세스는 운영체제 영역을 피하여 메모리에 적재
- 사용자 프로세스가 운영체제의 크기에 따라 매번 적재되는 주소가 달라지는 것은 번거로움. 이를 개선하여 사용자 프로세스를 메모리의 최상위부터 사용
- 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡하기 때문에 <b>잘 쓰이지 않음</b>

<img width="326" alt="스크린샷 2023-09-11 오후 3 41 58" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/31f2b49d-5d64-4bc2-81ba-fbe1c641e3f9">

### <br> 경계 레지스터
- 운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터, CPU 내에 있는 경계 레지스터가 사용자 영역이 운영체제 영역으로 침범하는 것을 막아줌
- 메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사하고, 만약 경계 레지스터를 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스를 종료

### <br> 절대 주소 absolute address
- 실제 물리 주소physical address를 가리키는, 메모리 주소 레지스터가 사용하는 주소
- 컴퓨터에 꽂힌 램 메모리의 실제 주소

### <br> 상대 주소 relative address
- 사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는, 사용자 프로세스 입장에서 바라본 주소
- 절대 주소와 관계없이 항상 0번지 부터 시작
- 프로세스 입장에서 상대 주소가 사용할 수 없는 영역의 위치를 알 필요가 없고, 주소가 항상 0번지부터 시작하기 때문에 편리

### <br> 절대 주소와 상대 주소의 차이
- 논리 주소 공간은 상대 주소를 사용하는 주소 공간
- 물리 주소 공간은 절대 주소를 사용하는 주소 공간

<img width="609" alt="스크린샷 2023-09-12 오후 7 01 51" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/96deed30-8da1-4a20-9456-c55faf2dbe30">

### <br> 상대 주소를 절대 주소로 변환하는 과정
- 메모리 접근 시 상대 주소를 사용하면 절대 주소로 변환해야 함 
- 메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소값에 재배치 레지스터 값을 더하여 절대 주소를 구함
- 재배치 레지스터는 주소 변환의 기본이 되는 주소값을 가진 레지스터로, 메모리에서 사용자 영역의 시작 주소값이 저장
  
<img width="751" alt="스크린샷 2023-09-12 오후 7 06 10" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/2526c7b5-22f2-47cc-9e00-2db4363f35a6">

1. 사용자 프로세스가 상대주소 40번지에 있는 데이터를 요청
2. CPU는 메모리 관리자에게 40번지에 있는 내용을 가져오라고 명령
3. 메모리 관리자는 replacement 레지스터를 사용하여 상대 주소 40번지를 절대 주소 400번지로 변환하고 메모리 400번지에 저장된 데이터를 가져옴

## <br> 3. 단일 프로그래밍 환경에서의 메모리 할당
## 3.1 메모리 오버레이
### 메모리 오버레이
- 프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 <b>적당한 크기</b>로 잘라서 가져오는 기법, 메모리 오버레이를 사용하면 물리 메모리보다 더 큰 프로그램도 실행 가능!

### <br> 메모리 오버레이의 작동 방식
- 프로그램이 실행되면 필요한 모듈만 메모리에 올라와 실행
  
<img width="684" alt="스크린샷 2023-09-12 오후 7 11 51" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/3f553dc5-8c6a-4198-9b74-c50ca5c6b745">

### <br> 메모리 오버레이의 의미
- 한정된 메모리에서 메모리보다 큰 프로그램 실행 가능
- 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행 가능

## <br> 3.2 스왑

### 스왑 영역 swap area
- 메모리가 모자라서 쫓겨난 프로세스를 저장장치의 특별한 공간에 모아두는 영역
- 메모리에서 쫓겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리
- 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용

### <br> 스왑인과 스왑아웃
- 스왑인 : 스왑 영역에서 메모리로 데이터를 가져오는 작업
- 스왑아웃 : 메모리에서 스왑 영역으로 데이터를 내보내는 작업 

<img width="727" alt="스크린샷 2023-09-12 오후 7 13 59" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/33e32a1a-7f2c-416f-8d2a-14389734e6e0">

## <br> 4. 다중 프로그래밍 환경에서의 메모리 할당
## 4.1 메모리 분할 방식

### 메모리에 여러 개의 프로세스를 배치하는 방법
- 가변 분할 방식 : 프로세스의 크기에 따라 메모리를 나누는 것
- 고정 분할 방식 : 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것

### <br> 식당 의자 비유
- 가변 분할 방식 : 손님의 신체 크기에 맞게 의자를 준비하는 것
- 고정 분할 방식 : 손님의 신체 크기와 상관없이 같은 크기의 의자를 준비하는 것
  
<img width="782" alt="스크린샷 2023-09-12 오후 7 14 37" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/01179100-b8f3-4354-af38-fa7baaf2047b">

### <br> 손님 자리 배치 비유
- 가변 분할 방식 : 어디에 앉든 제약이 없기 때문에 손님들이 알아서 편한 자리에 앉음
- 고정 분할 방식 : 의자를 4개씩 파티션으로 나누고 손님들의 자리를 파티션 단위로 배정 

### <br> 메모리 분할 방식의 구현
- 가변 분할 방식
  - 프로세스의 크기에 맞게 메모리가 분할
  - 메모리의 영역이 각각 다름
  - 연속 메모리 할당

- 고정 분할 방식
  - 프로세스의 크기에 상관없이 메모리가 같은 크기로 나뉨
  - 큰 프로세스가 메모리에 올라오면 여러 조각으로 나누어 배치
  - 비연속 메모리 할당

<img width="540" alt="스크린샷 2023-09-12 오후 7 19 35" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/d7b92a06-c316-43cb-81f9-9986090bdc82">

### <br> 가변 분할 방식의 장단점
- 장점 : 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치
- 단점 : 비어 있는 공간을 하나로 합쳐야 하며, 이 과정에서 다른 프로세스의 자리도 옮겨야 하므로 메모리 관리가 복잡함 

### <br> 고정 분할 방식의 장단점
- 장점 : 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리가 수월 (가변 분할 방식의 메모리 통합 같은 부가적인 작업을 할 필요가 없음)
- 단점 : 쓸모없는 공간으로 인해 메모리 낭비가 발생할 수 있음

## <br> 4.2 가변 분할 방식의 메모리 관리
### 가변 분할 방식과 외부 단편화
- 프로세스 A, B, C, D, E를 순서대로 배치했을 때 프로세스 B와 D가 종료되면 18KB와 17KB의 빈 공간이 생김
- 이후 18KB보다 큰 프로세스가 들어오면 적당한 공간이 없어 메모리를 배정하지 못하는데, 가변 분할 방식에서 발생하는 이러한 작은 빈 공간을외부 단편화라고 함 

<img width="428" alt="스크린샷 2023-09-12 오후 7 24 05" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/deaa0aed-3731-43e9-8f22-a48062fdcdc6">

### <br> 외부 단편화 해결
- 메모리 배치 방식 : 작은 조각이 발생하지 않도록 프로세스를 배치하는 것
- 조각 모음 : 조각이 발생했을 때 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 작업 

### <br> 메모리 배치 방식
- 최초 배치first fit 
  - 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법

- 최적 배치best fit 
  - 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법

- 최악 배치worst fit
  - 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법

### <br> 메모리 배치 방식 비교 

<img width="740" alt="스크린샷 2023-09-12 오후 7 26 44" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/95746341-9b35-477d-bb8b-43df7a25ad25">

- 최초 배치
  - 빈 공간을 찾아다닐 필요 없음

- 최적 배치
  - 빈 공간을 모두 확인하는 부가적인 작업이 있지만 딱 맞는 공간을 찾을 경우 단편화 일어나지 않음
  - 딱 맞는 공간이 없을 때는 아주 작은 조각을 만들어내는 단점이 있음

- 최악 배치
  - 프로세스를 배치하고 남은 공간이 크기 때문에 쓸모가 있음
  - 빈 공간의 크기가 클 때는 효과적이지만 빈 공간의 크기가 점점 줄어들면 최적 배치처럼 작은 조각을 만들어냄

### <br> 조각 모음
- 이미 배치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만드는 작업
- 조각 모음 순서
  
  <img width="416" alt="스크린샷 2023-09-12 오후 7 34 40" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/7611b115-8b0c-4a88-a617-3c12c9686e4e">
  
  1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춤
  2. 프로세스를 적당한 위치로 이동(프로세스가 원래의 위치에서 이동하기 때문에 프로세스의 상대 주소값을 바꿈)
  3. 작업을 다 마친 후 프로세스 다시 시작 

## <br> 4.3 고정 분할 방식의 메모리 관리 
### 고정 분할 방식의 프로세스 배치
- 분할된 크기는 20KB이므로 40KB인 프로세스 A는 프로세스 A1과 A2로 나뉘어 메모리에 할당
- 30KB인 프로세스 C는 프로세스 C1과 C2로 나뉘는데, 메모리에 남은 공간이 없으므로 프로세스 C2는 스왑 영역으로 옮겨짐

<img width="538" alt="스크린샷 2023-09-12 오후 7 37 06" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/e1374e03-3500-4370-a2ce-6c39f37abe1d">

### <br> 고정 분할 방식과 내부 단편화
- 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상
- 고정 분할 방식은 내부 단편화를 줄이기 위해 신중하게 메모리의 크기를 결정해서 나눠야 하지만 사용하는 프로세스의 크기가 제각각이기 때문에 메모리를 얼마로 나누느냐에 관한 정답은 없음

### <br> 가변 분할 방식과 고정 분할 방식의 비교 

<img width="651" alt="스크린샷 2023-09-12 오후 7 40 08" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/5f152c3c-68b6-4d9a-8996-9c69ebd9a2f6">

### <br> 버디 시스템의 작동 방식

1. 프로세스의 크기에 맞게 메모리를 ½로 자르고 프로세스를 메모리에 배치
2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어감
3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만듦

<img width="702" alt="스크린샷 2023-09-12 오후 7 41 31" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/54dc92ab-85b3-4685-b2a3-846d7826dd3d">

## <br> 4.4 버디 시스템
### 버디 시스템 특징
- 가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉨
- 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고, 메모리의 한 구역 내부에 조각이 생겨 내부 단편화 발생
- 비슷한 크기의 조각이 서로 모여 작은 조각을 통합하여 큰 조각을 만들기 쉬움

## <br> 5. [심화학습] 컴파일과 메모리 관리 
## 5.1 컴파일 과정
<img width="607" alt="스크린샷 2023-09-12 오후 7 44 04" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/4a332666-22ea-428a-ad23-a3c96ee66ec6">

## <br>5.2 변수와 메모리 할당 
### 변수와 메모리
 
<img width="763" alt="스크린샷 2023-09-12 오후 7 44 35" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/6443eca3-39ed-486d-8742-227cbb9deb2b">

### 컴파일러와 변수
- 컴파일러는 모든 변수에 대해 메모리를 확보하고 오류를 찾기 위해 심벌 테이블 유지

  <img width="357" alt="스크린샷 2023-09-12 오후 7 45 15" src="https://github.com/YangYubin12/OperatingSystem/assets/102217712/2b9937fa-d38e-4b57-a0e7-9f3e33b5a049">

- 컴파일러는 변수를 사용할 때마다 사용 범위를 넘는지 점검
- 컴파일러는 모든 변수를 메모리 주소로 바꾸어 기계어로 된 실행 파일을 만듦
- 컴파일러에 의해 만들어진 변수의 주소는 상대 주소임

<br>

## 출처
* [출처 1: 메모리주소](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A3%BC%EC%86%8C)
* [출처 2: OS Compiler vs Interpreter](https://velog.io/@jaeyunn_15/OS-Compiler-vs-Interpreter) &nbsp;
* [출처 3: 32비트 64비트 차이와 x64 x86 구분까지 모두 정리해보자](https://wordpowwer.tistory.com/85)
* [출처 4: OS는 할껀데 핵심만 합니다. 12편 Memory 개요, 메모리 관리, 정적 링킹과 동적 링킹, 절대 주소와 상대 주소](https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-12%ED%8E%B8-Memory-%EA%B0%9C%EC%9A%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%95%EC%A0%81-%EB%A7%81%ED%82%B9%EA%B3%BC-%EB%8F%99%EC%A0%81-%EB%A7%81%ED%82%B9-%EC%A0%88%EB%8C%80-%EC%A3%BC%EC%86%8C%EC%99%80-%EC%83%81%EB%8C%80-%EC%A3%BC%EC%86%8C)
* 출처 5: ch07_물리 메모리 관리 PPT
