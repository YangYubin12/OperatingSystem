# 운영체제: 프로세스 관리
> ✅ CPU스케줄링

## <br> 1. 선점형 스케줄링과 비선점형 스케줄링
### 1.1 CPU 스케줄러?
> 운영체제에서 관리자의 역할을 담당.
> <br> 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원의 배정을 결정.

### 1.2 선점형 스케줄링
* 운영체제가 필요하다고 판단하면 실행 상태에 있는 프로세스의 작업을 중단시키고 새로운 작업을 시작할 수 있는 방식.
* 하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합.
* 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용한다.

### 1.3 비선점형 스케줄링
* 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행되는 방식.
* 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음.
* 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음.
* CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세서가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어짐.
* 과거의 일괄 작업 시스템에서 사용하던 방식.

### 1.4 선점형 스케줄링과 비선점형 스케줄링의 비교
<img width="446" alt="스크린샷 2023-04-23 오후 5 40 45" src="https://user-images.githubusercontent.com/102217712/233829307-8556cc54-e27b-41bf-9894-899848db9d35.png">

## <br> 2. FCFS 스케줄링
### 2.1 FCFS 스케줄링 동작 방식
* 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식.
* 한 번 실행되면 그 프로세스가 끝나야만 다음 프로세스를 실행할 수 있음.
* 큐가 하나라 모든 프로세스는 우선 순위가 동일.

![image](https://user-images.githubusercontent.com/102217712/233829787-f590e72c-dbca-4224-84ff-9409227ef09c.png)

### 2.2 FCFS 스케줄링의 평균 대기 시간
<img width="440" alt="스크린샷 2023-04-23 오후 5 46 01" src="https://user-images.githubusercontent.com/102217712/233829523-6ccc4ce6-6dec-49ea-a3b9-99d31e636fd9.png">

### 2.3 FCFS 스케줄링의 평가
* 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어짐.
* 특히 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어짐.

### 2.4 FCFS 흐름
<img width="661" alt="스크린샷 2023-04-23 오후 5 53 05" src="https://user-images.githubusercontent.com/102217712/233829816-7f2be6ef-1f29-47df-8255-f73747552fb6.png">

## <br> 3. SJF 스케줄링
### 3.1 SJF 스케줄링의 동작 방식
* 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식.
* 최단 작업 우선 스케줄링이라고도 함.

![image](https://user-images.githubusercontent.com/102217712/233872226-cfe4a4bc-f758-491b-b67c-d04d7d1b16c8.png)

### 3.2 SJF 스케줄링의 평균 대기 시간
<img width="450" alt="스크린샷 2023-04-24 오전 8 36 29" src="https://user-images.githubusercontent.com/102217712/233872380-16cb25ef-993e-4b2d-8e3f-7a8417cf6d2a.png">

### 3.3 SJF 스케줄링의 평가
* 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어려움.
* 작업 시간이 길다는 이유만으로 계속 뒤로 밀려 공평성이 현저히 떨어짐. 이를 아사 현상이라 부름

### 3.4 에이징(나이먹기)
* 아사 현상의 완화 방법
* 프로세스가 양보할 수 있는 상한선을 정하는 방식.
* 프로세스가 자신의 순서를 양보할 때 마다 나이를 한 살씩 먹어 최대 몇 살까지 양보하도록 규정하는 것.

## <br> 4. HRN 스케줄링
### 4.1 HRN 스케줄링의 동작 방식

![image](https://user-images.githubusercontent.com/102217712/233875723-43bfc763-60fa-4b42-aa91-4569db987173.png)

* SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘.
* 최고 응답률 우산 스케줄링이라고도 함.
* 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려해 스케줄링을 하는 방식.
* 프로세스의 우선순위를 결정하는 기준은 다음과 같다.

  <img width="234" alt="스크린샷 2023-04-24 오전 8 42 33" src="https://user-images.githubusercontent.com/102217712/233872687-b4c3ff42-c5f9-4cf4-95a3-bdddc679f90a.png">

### 4.2 HRN 스케줄링의 평균 대기 시간
<img width="428" alt="스크린샷 2023-04-24 오전 9 31 55" src="https://user-images.githubusercontent.com/102217712/233875666-cc4b28eb-cdf2-4638-b94b-8ef75b9b457a.png">

### 4.3 HRN 스케줄링의 평가
* 실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 현상을 완화.
* 대기 시간이 긴 프로세스의 우선순위를 높임으로써 CPU를 할당받을 확률을 높임.
* 여전히 공평성이 위배되어 많이 사용되지 않음.

## <br> 5. 라운드 로빈 스케줄링
### 5.1 라운드 로빈 스케줄링의 동작 방식
![image](https://user-images.githubusercontent.com/102217712/233889792-1be1b566-c870-4272-8656-16a25d61bb3d.png)

* 한 프로세스가 할당받은 시간(타임 슬라이스) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식.
* 선점형 알고리즘 중 가장 단순하고 대표적인 방식.
* 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행.

### 5.2 라운드 로빈 스케줄링의 평균 대기 시간
<img width="421" alt="스크린샷 2023-04-24 오전 11 50 07" src="https://user-images.githubusercontent.com/102217712/233889569-1eb93217-4abb-4be7-a5a1-322f3e869527.png">

![image](https://user-images.githubusercontent.com/102217712/233891472-c84b4dd9-dec2-404c-88c5-0de20d37946c.png)

### 5.3 라운드 로빈 스케줄링?
* 타임 슬라이스의 크기와 문맥 교환
  - 라운드 로빈 스케줄링이 효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스를 적절히 설정해야 함.
* 타임 슬라이스가 큰 경우
  - 하나의 작업이 끝난 뒤 다음 작업이 시작되는 것처럼 보여 FCFS 스케줄링과 다를게 없음.
* 타임 슬라이스가 작은 경우
  - 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생.
* 그래서?
  - 타임 슬라이스는 되도록 작게 설정하되 문맥 교환에 걸리는 시간을 고려하여 적당한 크기로 하는 것이 중요.
  - 유닉스 운영체제에서는 타임 슬라이스가 대력 100 밀리초이다.
 
## <br> 6. SRT 우선 스케줄링
> SRT 수서고속철도 아님
### 6.1 SRT 스케줄링의 동작 방식
![image](https://user-images.githubusercontent.com/102217712/233890934-7f418adc-528b-4213-a3fe-686da63935d8.png)

* 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택 할 때 남아 있는 작업 시간이 가장 적인 프로세스를 선택.

### 6.2 SRT 스케줄링의 평균 대기 시간
<img width="395" alt="스크린샷 2023-04-24 오후 12 06 24" src="https://user-images.githubusercontent.com/102217712/233891320-b0a5a67c-924c-424c-a1a8-4e6f5b014ada.png">

### 6.3 SRT 스케줄링의 평가
* 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로 SJF 스케줄링에는 없는 작업이 추가됨.
* 운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않음.

## <br> 7. SRT 우선순위 스케줄링
### 7.1 우선순위 스케줄링의 동작 방식
* 프로세서의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘.
<img width="380" alt="스크린샷 2023-04-24 오후 12 10 20" src="https://user-images.githubusercontent.com/102217712/233891780-986007c9-a9bb-4629-8c19-16c40eee2d25.png">

### 7.2 우선순위 적용
* 우선순위는 비선점형 방식과 선점형 방식에 모두 적용할 수 있음.
  - (비선점형 방식) SJF 스케줄링 : 작업 시간이 짧은 프로세스에 높은 우선순위를 부여.
  - (비선점형 방식) HRN 스케줄링 : 작업 시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위를 부여.
  - (선점형 방식) SRT 스케줄링 : 남은 시간이 짧은 프로세스에 높은 우선순위를 부여.
  
### 7.3 고정, 변동 우선순위 알고리즘
* 고정 우선순위 알고리즘
  - 한 번 우선순위를 부여받으면 종료될 때까지 우선순위가 고정.
  - 단순하게 구현할 수 있지만 시시각각 변하는 시스템의 상황을 반영하지 못해 효율성이 떨어짐.
* 변동 우선순위 알고리즘
  - 일정 시간마다 우선순위가 변하여 일정 시간마다 우선순위를 새로 계산하고 이를 반영.
  - 복잡하지만 시스템의 상황을 반영하여 효율적인 운영 가능.

### 7.4 우선순위 스케줄링의 평가
* 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사 현상을 일으킴.
* 준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하기 때문에 오버헤드가 발생하여 시스템의 효율성을 떨어뜨림.

## <br> 8. 다단계 큐 스케줄링
### 8.1 다단계 큐 스케줄링의 동작 방식
* 우선순위에 따라 준비 큐를 여러 개 사용하는 방식.
* 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입
* 우선순위는 고정형 우선순위를 사용
* 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작됨
<img width="315" alt="스크린샷 2023-04-24 오후 12 14 55" src="https://user-images.githubusercontent.com/102217712/233892254-b757eb0b-be97-45f4-833e-e4fad9698f6d.png">

## <br> 9. 다단계 피드백 큐 스케줄링
### 9.1 다단계 피드백 큐 스케줄링의 동작 방식
* 프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화.
* 우선순위가 낮아진다고 할지라도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음.
* 우선순위에 따라 타임 슬라이스의 크기가 다름.
* 우선순위가 낮아질수록 CPU를 얻을 확률이 적어짐. 따라서 한번 CPU를 잡을 때 많이 작업하라고 낮은 우선순위의 타임 슬라이스를 크게 함.
* 마지막 큐에 있는(우선순위가 가장 낮은) 프로세스는 무한대의 타임 슬라이스를 얻음.
* 마지막 큐는 들어온 순서대로 작업을 마치는 FCFS 스케줄링 방식으로 동작.

![image](https://user-images.githubusercontent.com/102217712/233892551-861a608b-6fb2-4710-a42c-54a4a9d1e074.png)


## <br> + 스케줄링 알고리즘 관계도
![image](https://user-images.githubusercontent.com/102217712/233892462-37fd7091-1b77-44f4-8058-e320036a4bb0.png)

<br>

## 출처
* [출처 1: 프로세스 스케줄링 알고리즘, FCFS](https://taesung1993.tistory.com/94)
* [출처 2: 운영체제 OS 스케줄링 알고리즘 SJF 정리, 장점, 한계, non preemptive](https://jhnyang.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-OS%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SJFShortest-Job-First-%EC%A0%95%EB%A6%AC-%EC%9E%A5%EC%A0%90-%ED%95%9C%EA%B3%84-non-preemptive) &nbsp; 
* [출처 3: 3강 스케줄링 알고리즘](https://velog.io/@inhalin/knou-os-03)
* [출처 4: [운영체제] RR(Round Robin) 스케줄링](https://yoons2owo.tistory.com/27)
* Chapter 04 CPU 스케줄링 PPT
